> 해당 문서는 [Do it! 자료구조와 함께 배우는 알고리즘 입문 : 파이썬 편 (시바타 보요 저)](http://www.yes24.com/Product/Goods/91219874)을 보고 정리한 내용입니다.
- 본 문서에 작성된 코드는 **파이썬 (Python)** 으로 작성하였습니다.
- 책을 보며 공부하면서 도움이 된 파이썬 문법과 개념은 [Python 폴더](https://github.com/dudtjakdl/TIL/blob/main/Python)의 문서에 정리하였습니다.
- 그 외 추가 내용은 인터넷 검색을 통해 공부하고 덧붙여 정리하였습니다.

# 검색과 키
    검색 (search): 데이터 집합에서 원하는 값을 가진 원소를 찾아내는 행위
    키 (key): 검색 조건에서 주목하는 항목

대부분의 경우 키는 데이터의 일부이다. 데이터가 간단한 정수값이나 문자열이면 데이터값이 그대로 키값이 될 수도 있다. 검색에서 조건은 하나만 지정할 수도 있고, 논리곱 또는 논리합을 사용하여 복합 지정할 수도 있다.

# 검색 알고리즘 종류
- 배열 검색
    - 선형 검색 : 무작위로 늘어놓은 데이터 집합에서 검색을 수행
    - 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색을 수행
    - 해시법 : 추가, 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색을 수행

- 연결 리스트 검색

- 이진 검색 트리 검색

검색 시간, 계산 시간 뿐만 아니라 필요한 상황에 따라 용도, 목적, 실행 속도, 자료구조 등 여러 사항을 고려해서 *검색 이외의 작업에 들어가는 비용을 종합 평가하여 알고리즘을 선택*해야 한다.

# 배열 검색
## 선형 검색
    선형 검색 (linear search): 직선 모양(선형)으로 늘어선 배열에서 원하는 키값을 가진 원소를 찾을 때까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘

- 배열 검색 중 가장 기본적인 알고리즘이다. 
- 무작위로 늘어놓은(정렬되지 않은) 데이터 집합에서 검색을 수행한다.
- 순차 검색(sequential search)라고도 한다.
- 시간 복잡도는 O(n)이다.

**종료 조건**
    
    1. 검색할 값을 찾지 못하고 배열의 맨 끝을 지나간 경우 -> 검색 실패
    2. 검색할 값과 같은 원소를 찾는 경우 -> 검색 성공

```python
def seq_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key값이 같은 원소를 선형 검색"""
    i = 0

    while True:
        if i == len(a):
            return -1  # 검색에 실패하여 -1을 반환
        if a[i] == key:
            return i   # 검색에 성공하여 현재 조사한 배열의 인덱스를 반환
        i += 1
```

### 보초법 (sentinel method)
선형 검색의 2가지 종료 조건 중, *검색할 값을 찾지 못하고 배열의 맨 끝을 지나간 경우를 판단하는 조건* ```if i == len(a)```을 없애기 위한 방법.

*검색하고자 하는 키값을 배열의 맨 끝에 삽입*하여, 반복을 종료하는 판단 횟수를 줄일 수 있다. 이때 배열 끝에 삽입하는 데이터를 **보초(sentinel)** 라 한다.

```python
def seq_search(seq: Sequence, key: Any) -> int:
    """시퀀스 seq에서 key와 일치하는 원소를 선형 검색(보초법)"""
    a = copy.deepcopy(seq)  # seq를 복사
    a.append(key)           # 보초 key를 추가
 
    i = 0
    while True:
        if a[i] == key: 
            break  # 검색에 성공하면 while 문을 종료
        i += 1
    return -1 if i == len(seq) else i  # 찾은 원소가 배열의 원래 데이터인지 보초인지 판단 
```

반복문이 종료되면 찾은 원소가 배열의 원래 데이터인지 보초인지 판단한다. i 값이 len(seq)와 같으면 검색에 실패한 것을 나타내는 -1을 반환하고, 그렇지 않으면 검색 성공이므로 인덱스 i를 반환한다.

## 이진 검색
    이진 검색 (binary search): 원소가 오름차순이나 내림차순으로 정렬된 배열에서 좀 더 효율적으로 검색할 수 있는 알고리즘

- 배열의 데이터가 정렬되어 있어야 한다.
- 선형 검색보다 빠르게 검색할 수 있다.
- 검색할 값을 찾을 때까지 검색 범위를 반으로 좁히는 과정을 반복한다. 
- 시간 복잡도는 O(log n)이다.

**검색 범위를 좁히는 과정**

    a[pc] < key : 중앙(pc)에서 오른쪽으로 한 칸 이동하여 새로운 왼쪽 끝 pl로 지정하고, 검색 범위를 뒤쪽 절반으로 좁힌다.
    a[pc] > key : 중앙(pc)에서 왼쪽으로 한 칸 이동하여 새로운 오른쪽 끝 pr로 지정하고, 검색 범위를 앞쪽 절반으로 좁힌다.

pl: 검색 범위의 *맨 앞* 인덱스

pr: 검색 범위의 *맨 끝* 인덱스

pc: 검색 범위의 *중앙* 인덱스

**종료 조건**

    다음 조건 중 하나만 성립
    1. a[pc]와 key가 일치하는 경우
    2. 검색 범위가 더 이상 없는 경우

```python
def bin_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 일치하는 원소를 이진 검색"""
    pl = 0                      # 검색 범위 맨 앞 원소의 인덱스
    pr = len(a) - 1             # 검색 범위 맨 끝 원소의 인덱스

    while True:
        pc = (pl + pr) // 2     # 중앙 원소의 인덱스
        if a[pc] == key:
            return pc           # 검색 성공
        elif a[pc] < key:
            pl = pc + 1         # 검색 범위를 뒤쪽의 절반으로 좁힘
        else:
            pr = pc - 1         # 검색 범위를 앞쪽의 절반으로 좁힘
        if pl > pr:
            break
    return -1                   # 검색 실패
```

## 해시법
    해시법 (hashing): '데이터를 저장할 위치 = 인덱스'를 간단한 연산으로 구하는 것

- 추가, 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색을 수행한다.
- 원소의 검색뿐 아니라 추가, 삭제도 효율적으로 수행할 수 있다.

![해시법](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg/1200px-Hash_table_3_1_1_0_1_0_0_SP.svg.png)

    해시값 (hash value) : 배열의 키(원소의 값)을 정해진 공식으로 변환한 값. 데이터에 접근할 때 기준이 된다.
    해시 함수(hash funtion) : 키를 해시값으로 변환하는 과정. 일반적으로 해시 함수는 나머지를 구하는 연산을 응용한다.
    해시 테이블 (hash table) : 해시값을 인덱스로 하여 원소를 새로 저장한 배열    
    버킷(bucket) : 해시 테이블에서 만들어진 원소

## 해시 충돌

![해시 충돌](https://blog.kakaocdn.net/dn/TNDvL/btqGchu427s/wO1EQlG8B6Fn8FximK3HHK/img.png)

키와 해시값의 대응 관계가 꼭 1:1일 필요는 없다. 키와 해시값은 일반적으로 n:1 이다. 이처럼 저장할 버킷이 중복되는 현상을 **충돌(collision)** 이라 한다. 충돌을 피하려면 해시 함수가 해시 테이블 크기보다 작거나 같은 정수를 고르게 생성해야 한다.

해시법에서 충돌이 발생하는 경우 2가지 방법으로 대처할 수 있다.

    체인법: 해시값이 같은 원소를 연결 리스트로 관리
    오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복

### 체인법
체인법(chaining)이란 **해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결**하는 방법을 말하며, 오픈 해시법(open hashing) 이라고도 한다.

![체인법](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg/1280px-Hash_table_5_0_1_1_1_1_1_LL.svg.png)

배열의 각 버킷(해시 테이블)에 저장하는 것은 같은 해시값들을 가진 노드들을 이은 연결 리스트의 앞쪽 노드(head node)를 참조하는 값이다. 데이터가 하나도 없는 버킷의 값은 None으로 한다.

**체인법에서 원소를 검색하는 과정**

    1. 해시 함수를 사용하여 키를 해시값으로 변환
    2. 해시값을 인덱스로 하는 버킷에 주목
    3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 스캔
        키와 같은 값이 발견 -> 검색 성공
        원소의 맨 끝까지 스캔해서 발견되지 않음 -> 검색 실패

### 오픈 주소법
오픈 주소법(open addressing)이란 충돌이 발생했을 때 **재해시(rehashing)를 수행하여 빈 버킷을 찾는 방법** 을 말하며, 닫힌 해시법(closed hashing) 또는 선형 탐사법(linear probing) 이라고도 한다.

![오픈 주소법](https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Hash_table_5_0_1_1_1_1_0_SP.svg/1024px-Hash_table_5_0_1_1_1_1_0_SP.svg.png)

재해시를 위한 해시 함수는 자유롭게 정할 수 있다. 예를 들어 기존 해시 함수는 나머지를 구하는 연산을 적용했다면, 재해시를 위한 해시 함수는 키에 특정 값을 더하고 나머지를 구하는 연산을 적용하는 등 빈 버킷이 나올 때까지 재해시를 반복한다.

오픈 주소법에서 원소의 추가, 삭제 또는 검색을 원할히 수행하기 위해서 각 버킷에 다음과 같은 상태 속성을 부여하는 것이 좋다.

    - 데이터 저장되어 있음 -> OCCUPIED
    - 비어 있음 -> EMPTY
    - 삭제 완료 -> DELETED

**오픈 주소법에서 원소를 검색하는 과정**

    1. 해시 함수를 사용하여 키를 해시값으로 변환
    2. 해시값을 인덱스로 하는 버킷에 주목
    3. 주목한 버킷의 상태에 따라 판단이 달라짐
        3-1. 버킷의 상태가 EMPTY인 경우 -> 검색 실패
        3-2. 버킷의 상태가 DELETED인 경우 -> 재해시하여 위 과정 반복
        3-3. 버킷의 상태가 OCCUPIED인 경우 
                -> 검색하려는 키와 버킷의 키가 같은지 비교
                    -> 같으면 검색 성공
                    -> 다르면 재해시하여 위 과정 반복