> 해당 문서는 [Do it! 자료구조와 함께 배우는 알고리즘 입문 : 파이썬 편 (시바타 보요 저)](http://www.yes24.com/Product/Goods/91219874)을 보고 정리한 내용입니다.
- 본 문서에 작성된 코드는 **파이썬 (Python)** 으로 작성하였습니다.
- 책을 보며 공부하면서 도움이 된 파이썬 문법과 개념을 함께 정리하였습니다.
- 그 외 추가 내용은 인터넷 검색을 통해 공부하고 덧붙여 정리하였습니다.
# 기본 개념

## 알고리즘

    알고리즘 (algorithm) : 어떠한 문제를 해결하기 위해 정해 놓은 일련의 절차


- 올바른 알고리즘이란 **어떠한 경우에도 실행 결과가 똑같이 나오는 것**을 말한다.

- 알고리즘(또는 프로그램)이 흐르는 방향은 **조건식**이 결정한다.  이때 조건식에 따라 알고리즘 흐름이 두 갈래로 나뉘는 것을 **양 갈래 선택**이라 한다.

## 구조적 프로그래밍
- 구조적 프로그래밍 (structured programming) : 입력과 출력으로 이루어진 구성 요소를 계층으로 배치하여 *순차, 선택, 반복* 세 종류의 제어 흐름을 통해 프로그램을 구성하는 방법

- 순차 구조 (sequential structure) : 한 문장씩 순서대로 처리되는 구조

- 선택 구조 (select structure) : 조건식으로 평가한 결과에 따라 프로그램의 실행 흐름이 변경되는 구조 

- 반복 구조 (repetition structure) : 어떤 조건이 성립하는 동안 반복해서 처리하는 구조. 일반적으로 루프 (loop) 라고 함 
    - 사전 판단 반복 구조 : 반복을 계속할 것인지를 판단하는 구조
    - 루프 본문 : 반복 대상이 되는 명령문
    - 카운터용 변수 : 반복을 제어할 때 사용하는 변수

- 분기 (branching) : 프로그램의 실행 흐름을 다른 곳으로 변경하는 명령

## 가우스의 덧셈
1부터 n까지 정수의 합은 ```n x (n + 1) / 2``` 로 구할 수 있다. 이를 가우스의 덧셈이라고 한다.
```python
sum = n * (n + 1) // 2
```

## 드모르간의 법칙
드로므간의 법칙은 '각 조건을 부정하고 논리곱을 논리합으로, 논리합을 논리곱으로 바꾸고 다시 전체를 부정하면 원래의 조건과 같다'는 법칙이다.

    1. x and y와 not(not x or not y)의 논릿값은 같다.
    2. x or y와 not(not x and not y)의 논릿값은 같다.

# 순서도 (Flowchart)
순서도는 문제를 정의, 분석하고 해결하는 방법을 그림으로 표현한 것이다.
## 순서도 기호

![순서도 기호](https://t1.daumcdn.net/cfile/blog/241B2C4358F7554338)
- 단말 : 프로그램 흐름의 시작과 종료를 나타냄
- 선 : 제어의 흐름을 의미
- 준비 : 기억장소, 초기값 등 작업의 준비 과정을 나타냄
- 처리 : 여러 종류의 처리 기능. 연산이나 연산 집합의 실행
- 입출력 : 기억 장치을 지정하지 않은 데이터 자체. 일반적인 입출력을 나타내기 위한 기호
- 판단(조건) : 기호 안에 정의한 조건을 평가하여 하나의 출구를 선택하는 판단 기능을 나타냄
- 종속처리 : 서브루틴이나 모듈 등 다른 곳에서 이미 정의한 하나 이상의 연산 또는 명령으로 이루어진 처리
- 연결자(결합) : 다음에 처리할 순서가 있는 곳으로 연결
# 자료구조

    자료구조 (data structure) : 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계, 논리적인 관계로 이루어진 데이터 구성

자료구조를 알아야 하는 이유는 컴퓨터에서 처리해야 하는 많은 데이터를 모아 효율적으로 관리하고 구조화하는 데 있다.

# 배열

    배열 (array) : 번호와 번호에 대응하는 데이터들로 이루어져 묶음 단위로 값을 저장하는 자료 구조. 

- 배열에는 객체가 저장되며, 배열에 저장된 객체 하나하나를 **원소(element)** 라고 한다.
- 각 원소는 0, 1, 2, ... 순으로 **인덱스(index)** 를 부여받는다.
- 배열 원소를 하나씩 차례로 주목하여 살펴보는 방식을 알고리즘 용어로 **스캔(scan)** 이라 한다.

## 리스트 (list)

리스트는 원소를 변경할 수 있는 **뮤터블(mutable)** list 형 객체이다.

```python
list1 = []                 # [] 빈 리스트 생성
list2 = [1, 2, 3]          # [1, 2, 3]
list3 = ['A', 'B', 'C', ]  # ['A', 'B', 'C'] 맨 마지막 원소에 쉼표를 써도 됨

list4 = list()           # [] 빈 리스트 생성
list5 = list('ABC')      # ['A', 'B', 'C'] 각각의 문자로부터 원소 생성
list6 = list([1, 2, 3])  # [1, 2, 3] 리스트로부터 원소 생성
list7 = list((1, 2, 3))  # [1, 2, 3] 튜플로부터 원소 생성
list8 = list({1, 2, 3})  # [1, 2, 3] 집합으로부터 원소 생성

list9 = list(range(7))          # [0, 1, 2, 3, 4, 5, 6]
list10 = list(range(3, 8))      # [3, 4, 5, 6, 7]
list11 = list(range(3, 13, 2))  # [3, 5, 7, 9, 11]

lits12 = [None] * 5   # [None, None, None, None, None] 원소가 5개이면서 원소값이 없는 리스트
```

## 튜플 (tuple)

튜플은 원소에 순서를 매겨 결합한 것으로, 원소를 변경할 수 없는 **이뮤터블(immutable)** 자료형이다.

```python
tuple1 = ()              # ()
tuple2 = 1,              # (1,) 원소가 1개인 경우 쉼표 반드시 입력
tuple3 = (1,)            # (1,) 원소가 1개인 경우 쉼표 반드시 입력
tuple4 = 1, 2, 3         # (1, 2, 3)
tuple5 = 1, 2, 3,        # (1, 2, 3)
tuple6 = (1, 2, 3)       # (1, 2, 3)
tuple7 = (1, 2, 3, )     # (1, 2, 3)
tuple8 = 'A', 'B', 'C',  # ('A', 'B', 'C')

tuple9 = tuple()           # () 빈 튜플 생성
tuple10 = tuple('ABC')      # ('A', 'B', 'C') 문자열의 각 문자로부터 원소를 생성
tuple11 = tuple([1, 2, 3])  # (1, 2, 3) 리스트로부터 원소 생성
tuple12 = tuple({1, 2, 3})  # (1, 2, 3) 집합으로부터 원소 생성

tuple13 = tuple(range(7))         # (0, 1, 2, 3, 4, 5, 6)
tuple14 = tuple(range(3, 8))      # (3, 4, 5, 6, 7)
tuple15 = tuple(range(3, 13, 2))  # (3, 5, 7, 9, 11)
```
## 언팩 (unpack)

리스트나 튜플의 원솟값들을 풀어 여러 변수에 대입하는 것을 **언팩(unpack)** 이라 한다.
``` python
x = [1, 2, 3]   # 리스트 x 선언
a, b, c = x     # x를 언팩하여 변수 a, b, c에 대입
print(a, b, c)  # 1, 2, 3
```

## 슬라이스 (slice)

리스트 또는 튜플의 원소 일부를 연속해서 또는 일정한 간격으로 꺼내 새로운 리스트, 튜플을 만드는 것을 **슬라이스(slice)** 라고 한다.
```python
s[i:j]      # s[i]부터 s[j-1]까지 나열
s[i:j:k]    # s[i]부터 s[j-1]까지 k씩 건너뛰며 나열    
```

|패턴|설명|
|------|------|
|s[:]|리스트 s의 원소를 모두 출력|
|s[:n]|리스트 s의 원소 중 맨 앞에서부터 n개까지 출력|
|s[i:]|리스트 s의 원소 중 s[i]부터 맨 끝까지 출력|
|s[-n:]|리스트 s의 원소 중 -n에서부터 맨 끝까지 출력|
|s[::k]|리스트 s의 원소 중 맨 앞에서부터 k개씩 건너뛰며 출력|
|s[::-1]|리스트 s의 원소 중 맨 끝에서부터 전부 출력|

# 파이썬 개념

## 이터러블 객체
이터러블 객체란 **반복할 수 있는 객체**를 말하며, 파이썬의 대표적인 이터러블 자료형으로는 `list, str, tuple` 등이 있다.

## 뮤터블 자료형
`list, dic, set` 등이 있으며, 값을 변경할 수 있다.

## 이뮤터블 자료형
`int, float, str, tuple` 등이 있으며 값을 변경할 수 없다.
```python
# 예시
n = 12; n += 1

# int형 정수형 객체 12의 값 자체를 변경하는 것이 불가능하므로, 다른 정수형 객체 13을 참조하도록 업데이트한 것이다.
```


## range() 함수
range() 함수는 이터러블 객체를 생성한다.
```python
range(n) # 0 이상 n 미만인 수를 차례로 나열하는 수열
range(a, b) # a 이상 b 미만인 수를 차례로 나열하는 수열
range(a, b, step) # a 이상 b 미만인 수를 step 간격으로 나열하는 수열
```
## a와 b의 값을 교환
```python
a, b = b, a # a와 b의 값을 교환 (단일 대입문 사용)

if a > b:
    a, b = b, a # a와 b를 오름차순으로 정렬

# 우변의 b, a는 두값을 압축한 튜플 (b, a)로 생성된다.
```
## 파이썬 변수와 객체의 특징
파이썬에서는 데이터, 함수, 클래스, 모듈, 패키지 등을 모두 **객체(object)** 로 취급한다. 그래서 파이썬의 변수는 **값을 가지지 않는다**는 특징이 있다. 

즉, 변수에 어떤 값을 대입하면 값이 아니라 **식별 번호가 바뀐다.**

* 파이썬 변수는 객체를 참조하는 객체에 연결된 이름에 불과하다.
* 모든 객체는 메모리를 차지하고, 자료형뿐만 아니라 식별 번호(identity)를 가진다.
* 대입식은 값 자체가 아니라 참조하는 객체의 식별 번호를 대입한다.

```python
# 예시
>>> list1 = [1, 2, 3, 4, 5]
>>> list2 = list1
>>> list1 is list2
True
>>> list1[2] = 9
>>> list1
[1, 2, 9, 4, 5]
>>> list2
[1, 2, 9, 4, 5]
```
위 예시의 ```list2 = list1``` 대입문을 실행하면 list2는 list1이 참조하는 곳의 리스트를 참조한다. *즉, 대입에서 복사되는 것은 값이 아니라 참조하는 곳이다.*

따라서 list1의 원솟값이 바뀌면 list2의 원솟값도 바뀐다.
## 함수 어노테이션
파이썬에서는 자료형 선언없이 변수나 함수를 자유롭게 사용할 수 있지만, 명시적으로 해석하기 어려운 경우가 있다. 그래서 등장한 기능이 파이썬 3 이상에서 사용 가능한 *어노테이션(annotation, 주석 달기)* 이다. 함수 어노테이션은 함수의 **매개변수와 반환값의 자료형**을 나타내는 역할을 한다.

```python
# 예시
from typing import Any, Sequence

def max_of(a: Sequence) -> Any:
    """시퀀스형 a 원소의 최댓값을 반환"""
    maximum = a[0]
    for i in range(1, len(a)):
        if maximum > a[i]:
            maximum = a[i]
    return maximum

# Any: 제약이 없는 임의의 자료형을 의미
# Sequence: 시퀀스형을 의미. 리스트, 배열, 문자열, 튜플 등이 있음
```

## 모듈
파이썬에서 하나의 스크립트 프로그램을 **모듈(module)** 이라 한다. 확장자(.py)를 포함하지 않는 파일의 이름 자체를 모듈 이름으로 사용한다.

모듈도 객체이다. 모듈은 프로그램이 처음 임포트되는 시점에 그 모듈 객체가 생성되며 초기화 된다.

### __ name __
모듈 객체 __ name __은 모듈 이름을 나타내는 변수이며 작성 규칙은 다음과 같다.
- 스크립트 프로그램이 직접 실행될 때 변수 __ name __은 ' __main __' 이다.
- 스크립트 프로그램이 임포트될 때 변수 __ name __ 은 원래의 모듈 이름이다.

```python
# 예시
if __name__ == "__main__":
    print("스크립트 프로그램을 직접 시행할 때만 출력")

# 스크립트 프로그램을 직접 시행했을 경우 참이 되어 프린트문 출력
# 다른 스크립트 프로그램에서 임포트한 경우에는 거짓이 되므로 if문 실행 X
```